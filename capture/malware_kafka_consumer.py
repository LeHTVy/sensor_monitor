#!/usr/bin/env python3
"""
Malware Analysis Kafka Consumer
Processes malware samples from Kafka topics and coordinates analysis pipeline
"""

import json
import os
from kafka import KafkaConsumer
from datetime import datetime
from typing import Dict, Optional
import logging
from malware_collector import MalwareCollector

# Setup logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


class MalwareAnalysisConsumer:
    """
    Consumes malware-related events from Kafka and triggers analysis pipeline
    """

    def __init__(self, 
                 kafka_servers=['kafka:9092'],
                 topics=['malware-samples', 'honeypot-attacks'],
                 group_id='malware-analysis-group'):
        
        self.kafka_servers = kafka_servers
        self.topics = topics
        self.group_id = group_id
        self.running = False
        
        # Initialize malware collector
        self.collector = MalwareCollector()
        
        # Initialize Kafka consumer
        try:
            self.consumer = KafkaConsumer(
                *self.topics,
                bootstrap_servers=self.kafka_servers,
                group_id=self.group_id,
                value_deserializer=lambda m: json.loads(m.decode('utf-8')),
                auto_offset_reset='latest',
                enable_auto_commit=True
            )
            logger.info(f"‚úÖ Kafka consumer connected: {self.kafka_servers}")
            logger.info(f"   Topics: {self.topics}")
            logger.info(f"   Group ID: {self.group_id}")
        except Exception as e:
            logger.error(f"‚ùå Failed to connect to Kafka: {e}")
            self.consumer = None

    def process_malware_sample(self, message: Dict) -> Optional[Dict]:
        """
        Process a malware sample detection event
        
        Message format:
        {
            "event_type": "file_upload" | "payload_detected" | "download_attempt",
            "source_ip": "attacker IP",
            "timestamp": "ISO datetime",
            "file_data": "base64 encoded file data or file path",
            "original_filename": "filename",
            "attack_id": "elasticsearch doc ID",
            "context": {additional metadata}
        }
        """
        try:
            event_type = message.get('event_type', 'unknown')
            source_ip = message.get('source_ip', 'unknown')
            attack_id = message.get('attack_id')
            
            logger.info(f"ü¶† Processing malware event: {event_type} from {source_ip}")
            
            # Handle different event types
            if event_type == 'file_upload':
                metadata = self._handle_file_upload(message)
            elif event_type == 'payload_detected':
                metadata = self._handle_payload_detection(message)
            elif event_type == 'download_attempt':
                metadata = self._handle_download_attempt(message)
            else:
                logger.warning(f"‚ö†Ô∏è  Unknown event type: {event_type}")
                return None
            
            if metadata:
                # Send metadata to malware-metadata topic for further processing
                self._send_to_analysis_queue(metadata)
                logger.info(f"‚úÖ Malware sample collected: {metadata['file_id']}")
                return metadata
            
            return None
            
        except Exception as e:
            logger.error(f"‚ùå Error processing malware sample: {e}")
            import traceback
            logger.error(traceback.format_exc())
            return None

    def _handle_file_upload(self, message: Dict) -> Optional[Dict]:
        """Handle file upload events from honeypot"""
        try:
            # Check if file_path is provided (file already stored)
            if 'file_path' in message:
                # File already saved by honeypot
                metadata = self.collector.collect_file(
                    file_path=message['file_path'],
                    source_ip=message['source_ip'],
                    original_filename=message.get('original_filename'),
                    capture_method='file_upload',
                    attack_id=message.get('attack_id'),
                    additional_metadata=message.get('context', {})
                )
                return metadata
            
            # Handle base64 encoded file data
            elif 'file_data_base64' in message:
                import base64
                file_data = base64.b64decode(message['file_data_base64'])
                
                metadata = self.collector.collect_from_payload(
                    payload_data=file_data,
                    source_ip=message['source_ip'],
                    payload_type='uploaded_file',
                    attack_id=message.get('attack_id'),
                    context={
                        'original_filename': message.get('original_filename'),
                        **message.get('context', {})
                    }
                )
                return metadata
            
            else:
                logger.warning("‚ö†Ô∏è  No file data found in upload event")
                return None
                
        except Exception as e:
            logger.error(f"‚ùå Error handling file upload: {e}")
            return None

    def _handle_payload_detection(self, message: Dict) -> Optional[Dict]:
        """Handle detected malicious payload (shellcode, scripts, etc.)"""
        try:
            payload_data = message.get('payload_data', b'')
            
            # Convert hex string to bytes if needed
            if isinstance(payload_data, str):
                if payload_data.startswith('0x'):
                    payload_data = bytes.fromhex(payload_data[2:])
                else:
                    payload_data = payload_data.encode('utf-8')
            
            metadata = self.collector.collect_from_payload(
                payload_data=payload_data,
                source_ip=message['source_ip'],
                payload_type=message.get('payload_type', 'shellcode'),
                attack_id=message.get('attack_id'),
                context=message.get('context', {})
            )
            
            return metadata
            
        except Exception as e:
            logger.error(f"‚ùå Error handling payload detection: {e}")
            return None

    def _handle_download_attempt(self, message: Dict) -> Optional[Dict]:
        """Handle malware download attempts (wget, curl from URLs)"""
        try:
            download_url = message.get('url')
            
            if not download_url:
                logger.warning("‚ö†Ô∏è  No URL provided for download attempt")
                return None
            
            # For now, just log the attempt
            # In future, could actually download and analyze
            logger.info(f"üì• Download attempt detected: {download_url}")
            logger.info(f"   (Not downloading - would require safe download infrastructure)")
            
            # Could implement safe download in future:
            # metadata = self._download_safely(download_url, message['source_ip'])
            
            return None
            
        except Exception as e:
            logger.error(f"‚ùå Error handling download attempt: {e}")
            return None

    def _send_to_analysis_queue(self, metadata: Dict):
        """
        Send malware metadata to analysis queue for YARA scanning, etc.
        This will be consumed by other services (yara_scanner, sandbox_submitter, etc.)
        """
        try:
            # For now, just log
            # In Phase 2, we'll send to Kafka topic: malware-analysis-queue
            logger.info(f"üì§ Would send to analysis queue: {metadata['file_id']}")
            logger.info(f"   SHA256: {metadata['hashes']['sha256']}")
            logger.info(f"   Type: {metadata['file_type']['category']}")
            
            # TODO: Implement Kafka producer
            # producer.send('malware-analysis-queue', value=metadata)
            
        except Exception as e:
            logger.error(f"‚ùå Error sending to analysis queue: {e}")

    def process_honeypot_attack(self, message: Dict):
        """
        Process general honeypot attack logs
        Look for file upload indicators or payload patterns
        """
        try:
            # Check if this attack involved file uploads
            if message.get('method') == 'POST' and message.get('form_data'):
                # Check for file uploads in form data
                form_data = message.get('form_data', {})
                
                # Simple heuristic: look for file-like fields
                for field, value in form_data.items():
                    if any(keyword in field.lower() for keyword in ['file', 'upload', 'attachment', 'document']):
                        logger.info(f"üîç Potential file upload detected in field: {field}")
                        # Would trigger file extraction here
            
            # Check for suspicious payloads in query strings or POST data
            suspicious_patterns = ['eval(', 'exec(', 'system(', 'base64_decode', '<?php']
            
            payload_text = str(message.get('args', '')) + str(message.get('form_data', ''))
            
            if any(pattern in payload_text for pattern in suspicious_patterns):
                logger.info(f"üö® Suspicious payload pattern detected from {message.get('src_ip')}")
                # Could extract and analyze the payload
            
        except Exception as e:
            logger.error(f"‚ùå Error processing honeypot attack: {e}")

    def run(self):
        """Start consuming messages from Kafka"""
        if not self.consumer:
            logger.error("‚ùå Kafka consumer not initialized")
            return
        
        logger.info(f"üöÄ Starting malware analysis consumer...")
        self.running = True
        
        try:
            for message in self.consumer:
                if not self.running:
                    break
                
                topic = message.topic
                value = message.value
                
                logger.debug(f"üì® Received message from topic: {topic}")
                
                if topic == 'malware-samples':
                    # Direct malware sample events
                    self.process_malware_sample(value)
                    
                elif topic == 'honeypot-attacks':
                    # Honeypot attack logs (look for malware indicators)
                    self.process_honeypot_attack(value)
                
        except KeyboardInterrupt:
            logger.info("üõë Stopping consumer (Ctrl+C)")
        except Exception as e:
            logger.error(f"‚ùå Consumer error: {e}")
            import traceback
            logger.error(traceback.format_exc())
        finally:
            self.stop()

    def stop(self):
        """Stop the consumer"""
        self.running = False
        if self.consumer:
            self.consumer.close()
            logger.info("‚úÖ Consumer stopped")


def main():
    """Run malware analysis consumer"""
    print("="*60)
    print("Malware Analysis Kafka Consumer")
    print("="*60)
    
    # Get Kafka configuration from environment
    kafka_servers = os.getenv('KAFKA_SERVERS', 'localhost:9092').split(',')
    
    consumer = MalwareAnalysisConsumer(
        kafka_servers=kafka_servers,
        topics=['malware-samples', 'honeypot-attacks']
    )
    
    # Print current statistics
    stats = consumer.collector.get_statistics()
    print(f"\nüìä Current Malware Collection:")
    print(f"   Total samples: {stats.get('total_samples', 0)}")
    print(f"   Unique sources: {stats.get('unique_sources', 0)}")
    print(f"   Categories: {stats.get('by_category', {})}")
    print()
    
    # Start consuming
    consumer.run()


if __name__ == "__main__":
    main()
