#!/usr/bin/env python3
"""
Malware Analysis Kafka Consumer
Receives pre-analyzed malware samples from honeypot and stores in Elasticsearch.
Analysis runs on honeypot, this just stores results.
"""

import json
import os
from kafka import KafkaConsumer
from datetime import datetime
from typing import Dict, Optional
import logging
from elasticsearch import Elasticsearch

# Setup logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


class MalwareAnalysisConsumer:
    """
    Receives pre-analyzed malware samples from honeypot and stores in Elasticsearch.
    """

    def __init__(self, 
                 kafka_servers=['kafka:9092'],
                 topics=['malware-samples'],
                 group_id='malware-analysis-group'):
        
        self.kafka_servers = kafka_servers
        self.topics = topics
        self.group_id = group_id
        self.running = False
        
        # Initialize Elasticsearch client
        es_url = os.getenv('ELASTICSEARCH_URL', 'http://elasticsearch:9200')
        self.es = Elasticsearch([es_url])
        self.es_index = os.getenv('ES_INDEX_PREFIX', 'malware') + '-analysis'
        
        # Initialize Kafka consumer
        try:
            self.consumer = KafkaConsumer(
                *self.topics,
                bootstrap_servers=self.kafka_servers,
                group_id=self.group_id,
                value_deserializer=lambda m: json.loads(m.decode('utf-8')),
                auto_offset_reset='latest',
                enable_auto_commit=True
            )
            logger.info(f"‚úÖ Kafka consumer connected: {self.kafka_servers}")
            logger.info(f"   Topics: {self.topics}")
            logger.info(f"   Group ID: {self.group_id}")
        except Exception as e:
            logger.error(f"‚ùå Failed to connect to Kafka: {e}")
            self.consumer = None

    def process_malware_sample(self, message: Dict) -> Optional[Dict]:
        """
        Process a malware sample detection event
        
        Message format:
        {
            "event_type": "file_upload" | "payload_detected" | "download_attempt",
            "source_ip": "attacker IP",
            "timestamp": "ISO datetime",
            "file_data": "base64 encoded file data or file path",
            "original_filename": "filename",
            "attack_id": "elasticsearch doc ID",
            "context": {additional metadata}
        }
        """
        try:
            event_type = message.get('event_type', 'unknown')
            source_ip = message.get('source_ip', 'unknown')
            
            logger.info(f"ü¶† Processing malware event: {event_type} from {source_ip}")
            
            # Check if analysis was already done on honeypot
            if message.get('static_analysis') or message.get('risk_level'):
                # Analysis came from honeypot - just store it
                logger.info(f"üì• Received pre-analyzed file: {message.get('original_filename')}")
                logger.info(f"   Risk Level: {message.get('risk_level', 'UNKNOWN')}")
                logger.info(f"   Risk Score: {message.get('risk_score', 0)}")
                
                # Store in Elasticsearch
                self._store_in_elasticsearch(message)
                return message
            
            # Legacy: handle events without pre-analysis
            if event_type == 'file_upload':
                metadata = self._handle_file_upload(message)
            elif event_type == 'payload_detected':
                metadata = self._handle_payload_detection(message)
            elif event_type == 'download_attempt':
                metadata = self._handle_download_attempt(message)
            else:
                logger.warning(f"‚ö†Ô∏è  Unknown event type: {event_type}")
                return None
            
            if metadata:
                self._store_in_elasticsearch(metadata)
                return metadata
            
            return None
            
        except Exception as e:
            logger.error(f"‚ùå Error processing malware sample: {e}")
            import traceback
            logger.error(traceback.format_exc())
            return None

    def _handle_file_upload(self, message: Dict) -> Optional[Dict]:
        """Handle file upload events from honeypot"""
        try:
            # Check if file_path is provided (file already stored)
            if 'file_path' in message:
                # File already saved by honeypot
                metadata = self.collector.collect_file(
                    file_path=message['file_path'],
                    source_ip=message['source_ip'],
                    original_filename=message.get('original_filename'),
                    capture_method='file_upload',
                    attack_id=message.get('attack_id'),
                    additional_metadata=message.get('context', {})
                )
                return metadata
            
            # Handle base64 encoded file data
            elif 'file_data_base64' in message:
                import base64
                file_data = base64.b64decode(message['file_data_base64'])
                
                metadata = self.collector.collect_from_payload(
                    payload_data=file_data,
                    source_ip=message['source_ip'],
                    payload_type='uploaded_file',
                    attack_id=message.get('attack_id'),
                    context={
                        'original_filename': message.get('original_filename'),
                        **message.get('context', {})
                    }
                )
                return metadata
            
            else:
                logger.warning("‚ö†Ô∏è  No file data found in upload event")
                return None
                
        except Exception as e:
            logger.error(f"‚ùå Error handling file upload: {e}")
            return None

    def _handle_payload_detection(self, message: Dict) -> Optional[Dict]:
        """Handle detected malicious payload (shellcode, scripts, etc.)"""
        try:
            payload_data = message.get('payload_data', b'')
            
            # Convert hex string to bytes if needed
            if isinstance(payload_data, str):
                if payload_data.startswith('0x'):
                    payload_data = bytes.fromhex(payload_data[2:])
                else:
                    payload_data = payload_data.encode('utf-8')
            
            metadata = self.collector.collect_from_payload(
                payload_data=payload_data,
                source_ip=message['source_ip'],
                payload_type=message.get('payload_type', 'shellcode'),
                attack_id=message.get('attack_id'),
                context=message.get('context', {})
            )
            
            return metadata
            
        except Exception as e:
            logger.error(f"‚ùå Error handling payload detection: {e}")
            return None

    def _handle_download_attempt(self, message: Dict) -> Optional[Dict]:
        """Handle malware download attempts (wget, curl from URLs)"""
        try:
            download_url = message.get('url')
            
            if not download_url:
                logger.warning("‚ö†Ô∏è  No URL provided for download attempt")
                return None
            
            # For now, just log the attempt
            # In future, could actually download and analyze
            logger.info(f"üì• Download attempt detected: {download_url}")
            logger.info(f"   (Not downloading - would require safe download infrastructure)")
            
            # Could implement safe download in future:
            # metadata = self._download_safely(download_url, message['source_ip'])
            
            return None
            
        except Exception as e:
            logger.error(f"‚ùå Error handling download attempt: {e}")
            return None

    def _store_in_elasticsearch(self, result: Dict):
        """Store analysis result in Elasticsearch"""
        try:
            doc_id = result.get('file_id', result.get('hashes', {}).get('sha256', 'unknown'))
            
            self.es.index(
                index=self.es_index,
                id=doc_id,
                body=result
            )
            logger.info(f"üì§ Stored analysis in Elasticsearch: {doc_id}")
            
        except Exception as e:
            logger.error(f"‚ùå Error storing in Elasticsearch: {e}")

    def _send_to_analysis_queue(self, metadata: Dict):
        """Legacy method - now handled by static analyzer directly"""
        pass

    def process_honeypot_attack(self, message: Dict):
        """
        Process general honeypot attack logs
        Look for file upload indicators or payload patterns
        """
        try:
            # Check if this attack involved file uploads
            if message.get('method') == 'POST' and message.get('form_data'):
                # Check for file uploads in form data
                form_data = message.get('form_data', {})
                
                # Simple heuristic: look for file-like fields
                for field, value in form_data.items():
                    if any(keyword in field.lower() for keyword in ['file', 'upload', 'attachment', 'document']):
                        logger.info(f"üîç Potential file upload detected in field: {field}")
                        # Would trigger file extraction here
            
            # Check for suspicious payloads in query strings or POST data
            suspicious_patterns = ['eval(', 'exec(', 'system(', 'base64_decode', '<?php']
            
            payload_text = str(message.get('args', '')) + str(message.get('form_data', ''))
            
            if any(pattern in payload_text for pattern in suspicious_patterns):
                logger.info(f"üö® Suspicious payload pattern detected from {message.get('src_ip')}")
                # Could extract and analyze the payload
            
        except Exception as e:
            logger.error(f"‚ùå Error processing honeypot attack: {e}")

    def run(self):
        """Start consuming messages from Kafka"""
        if not self.consumer:
            logger.error("‚ùå Kafka consumer not initialized")
            return
        
        logger.info(f"üöÄ Starting malware analysis consumer...")
        self.running = True
        
        try:
            for message in self.consumer:
                if not self.running:
                    break
                
                topic = message.topic
                value = message.value
                
                logger.debug(f"üì® Received message from topic: {topic}")
                
                if topic == 'malware-samples':
                    # Direct malware sample events
                    self.process_malware_sample(value)
                    
                elif topic == 'honeypot-attacks':
                    # Honeypot attack logs (look for malware indicators)
                    self.process_honeypot_attack(value)
                
        except KeyboardInterrupt:
            logger.info("üõë Stopping consumer (Ctrl+C)")
        except Exception as e:
            logger.error(f"‚ùå Consumer error: {e}")
            import traceback
            logger.error(traceback.format_exc())
        finally:
            self.stop()

    def stop(self):
        """Stop the consumer"""
        self.running = False
        if self.consumer:
            self.consumer.close()
            logger.info("‚úÖ Consumer stopped")


def main():
    """Run malware analysis consumer"""
    print("="*60)
    print("Malware Analysis Kafka Consumer")
    print("="*60)
    
    # Get Kafka configuration from environment
    kafka_servers = os.getenv('KAFKA_SERVERS', 'localhost:9092').split(',')
    
    consumer = MalwareAnalysisConsumer(
        kafka_servers=kafka_servers,
        topics=['malware-samples', 'honeypot-attacks']
    )
    
    # Print current statistics
    stats = consumer.collector.get_statistics()
    print(f"\nüìä Current Malware Collection:")
    print(f"   Total samples: {stats.get('total_samples', 0)}")
    print(f"   Unique sources: {stats.get('unique_sources', 0)}")
    print(f"   Categories: {stats.get('by_category', {})}")
    print()
    
    # Start consuming
    consumer.run()


if __name__ == "__main__":
    main()
